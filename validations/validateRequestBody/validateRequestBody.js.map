{"version":3,"sources":["../../src/validations/validateRequestBody/validateRequestBody.js"],"names":["require","isFunction","isEmpty","isArray","isNil","addReqBodyError","reqBodyErrors","prop","message","push","checkifPropExists","item","propValue","name","invokeValidators","validator","validatorResult","call","handleNonArrayRequestBody","reqbodydefs","req","forEach","index","body","nullable","allValid","length","errors","handleArrayRequestBody","map","itemIndex","definition","itemErrors","filter","x","validateRequestBody","module","exports"],"mappings":"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","file":"validateRequestBody.js","sourcesContent":["const {\n  isFunction,\n  isEmpty,\n  isArray,\n  isNil,\n} = require('lodash');\n\n/**\n * Add to errors list.\n * @param {any} reqBodyErrors\n * @param {any} prop\n * @param {any} message\n */\nconst addReqBodyError = (reqBodyErrors, prop, message) => {\n  reqBodyErrors.push({\n    prop,\n    message,\n  });\n};\n\n/**\n * Check if prop exists\n * @param {any} reqBodyErrors\n * @param {any} item\n */\nconst checkifPropExists = (reqBodyErrors, item, propValue) => {\n  if (item && isNil(propValue)) {\n    addReqBodyError(reqBodyErrors, item.name, `Property [${item.name}] is required.`);\n  }\n};\n\n/**\n * Invoke validators defined.\n * @param {any} item\n * @param {any} propValue\n * @param {any} reqBodyErrors\n */\nconst invokeValidators = (item, propValue, reqBodyErrors) => {\n  const { validator } = item;\n  if (validator) {\n    if (isFunction(validator)) {\n      const validatorResult = validator.call(this, propValue);\n      // Validators function should always return boolean type\n      if (typeof (validatorResult) !== 'boolean') {\n        addReqBodyError(reqBodyErrors, item.name, `Property [${item.name}] validator [${validator.name}] not returning boolean.`);\n        // Validation failed\n      } else if (!validatorResult) {\n        addReqBodyError(reqBodyErrors, item.name, `Validation failed for Property [${item.name}] using validator [${validator.name}]`);\n      }\n    } else {\n      addReqBodyError(reqBodyErrors, item.name, `Property [${item.name}] validator property is not a function or there is no value to validate.`);\n    }\n  }\n};\n\nconst handleNonArrayRequestBody = (reqbodydefs, req) => {\n  const reqBodyErrors = [];\n  Object.keys(reqbodydefs)\n    .forEach((index) => {\n      const item = reqbodydefs[index];\n      const propValue = req.body[item.name];\n      const { nullable } = item;\n\n      if (!nullable) {\n        // Validate if prop has value\n        checkifPropExists(reqBodyErrors, item, propValue);\n        invokeValidators(item, propValue, reqBodyErrors);\n      } else {\n        // Invoke validator function if there is one provided\n        invokeValidators(item, propValue, reqBodyErrors);\n      }\n    });\n  return {\n    allValid: reqBodyErrors.length <= 0,\n    errors: reqBodyErrors,\n  };\n};\n\n\nconst handleArrayRequestBody = (req, reqbodydefs) => {\n  const errors = req.body.map((item, itemIndex) => {\n    const reqBodyErrors = [];\n    Object.keys(reqbodydefs)\n      .forEach((index) => {\n        const definition = reqbodydefs[index];\n        const propValue = item[definition.name];\n        const {\n          nullable,\n        } = definition;\n        if (!nullable) {\n          // Validate if prop has value\n          checkifPropExists(reqBodyErrors, item, propValue);\n          invokeValidators(definition, propValue, reqBodyErrors);\n        } else {\n          // Invoke validator function if there is one provided\n          invokeValidators(definition, propValue, reqBodyErrors);\n        }\n      });\n    return {\n      itemIndex,\n      itemErrors: reqBodyErrors,\n    };\n  });\n\n  return {\n    allValid: errors.filter(x => x.itemErrors.length > 0).length <= 0,\n    errors,\n  };\n};\n\n\n/**\n * Validate request body based on the definition\n * @param {any} req\n * @param {any} reqbodydefs\n * [\n *  {\n *      \"name\": Property Name (Case-sensitive),\n *      \"validator\": function to validate should always return bool, otherwise it will fail\n *  }\n * ]\n * @returns\n * {\n *      \"allValid\": true / false,\n *      \"errors\" : [\n *                  {\n *                      \"prop\": Property Name,\n *                      \"message\": Error Message\n *                  },\n *                  ...\n *                 ]\n * }\n */\nconst validateRequestBody = (req, reqbodydefs) => {\n  if (isEmpty(req.body)) {\n    return {\n      allValid: false,\n      errors: ['Please pass a request body.'],\n    };\n  }\n  if (!isArray(req.body)) {\n    return handleNonArrayRequestBody(reqbodydefs, req);\n  }\n  return handleArrayRequestBody(req, reqbodydefs);\n};\n\nmodule.exports = validateRequestBody;\n"]}