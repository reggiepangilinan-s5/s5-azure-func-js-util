{"version":3,"sources":["../../src/validations/validateRequestBody/validateRequestBody.js"],"names":["require","isFunction","isNil","isArray","addReqBodyError","reqBodyErrors","prop","message","push","checkifPropExists","item","propValue","name","invokeValidators","validatorFunction","validator","validatorResult","call","handleNonArrayRequestBody","reqbodydefs","req","forEach","index","body","nullable","allValid","length","errors","handleArrayRequestBody","map","itemIndex","definition","itemErrors","filter","x","validateRequestBody","module","exports"],"mappings":";;;;;;;;eAAuCA,QAAQ,QAAR,C;IAA/BC,U,YAAAA,U;IAAYC,K,YAAAA,K;IAAOC,O,YAAAA,O;;AAE3B;;;;;;;;AAMA,IAAMC,kBAAkB,SAAlBA,eAAkB,CAACC,aAAD,EAAgBC,IAAhB,EAAsBC,OAAtB,EAAkC;AACxDF,gBAAcG,IAAd,CAAmB;AACjBF,cADiB;AAEjBC;AAFiB,GAAnB;AAID,CALD;;AAOA;;;;;AAKA,IAAME,oBAAoB,SAApBA,iBAAoB,CAACJ,aAAD,EAAgBK,IAAhB,EAAsBC,SAAtB,EAAoC;AAC5D,MAAID,QAAQR,MAAMS,SAAN,CAAZ,EAA8B;AAC5BP,oBAAgBC,aAAhB,EAA+BK,KAAKE,IAApC,iBAAuDF,KAAKE,IAA5D;AACD;AACF,CAJD;;AAMA;;;;;;AAMA,IAAMC,mBAAmB,SAAnBA,gBAAmB,CAACH,IAAD,EAAOC,SAAP,EAAkBN,aAAlB,EAAoC;AAC3D,MAAMS,oBAAoBJ,KAAKK,SAA/B;AACA,MAAID,iBAAJ,EAAuB;AACrB,QAAIb,WAAWa,iBAAX,KAAiC,CAACZ,MAAMS,SAAN,CAAtC,EAAwD;AACtD,UAAMK,kBAAkBF,kBAAkBG,IAAlB,YAA6BN,SAA7B,CAAxB;AACA;AACA,UAAI,OAAQK,eAAR,KAA6B,SAAjC,EAA4C;AAC1CZ,wBAAgBC,aAAhB,EAA+BK,KAAKE,IAApC,iBAAuDF,KAAKE,IAA5D,qBAAgFE,kBAAkBF,IAAlG;AACA;AACD,OAHD,MAGO,IAAI,CAACI,eAAL,EAAsB;AAC3BZ,wBAAgBC,aAAhB,EAA+BK,KAAKE,IAApC,uCAA6EF,KAAKE,IAAlF,2BAA4GE,kBAAkBF,IAA9H;AACD;AACF,KATD,MASO;AACLR,sBAAgBC,aAAhB,EAA+BK,KAAKE,IAApC,iBAAuDF,KAAKE,IAA5D;AACD;AACF;AACF,CAhBD;;AAkBA,IAAMM,4BAA4B,SAA5BA,yBAA4B,CAACC,WAAD,EAAcC,GAAd,EAAsB;AACtD,MAAMf,gBAAgB,EAAtB;AACA,sBAAYc,WAAZ,EACGE,OADH,CACW,UAACC,KAAD,EAAW;AAClB,QAAMZ,OAAOS,YAAYG,KAAZ,CAAb;AACA,QAAMX,YAAYS,IAAIG,IAAJ,CAASb,KAAKE,IAAd,CAAlB;AAFkB,QAGVY,QAHU,GAGGd,IAHH,CAGVc,QAHU;;AAIlB,QAAIA,QAAJ,EAAc;AACZ;AACD;AACD;AACAf,sBAAkBJ,aAAlB,EAAiCK,IAAjC,EAAuCC,SAAvC;AACA;AACAE,qBAAiBH,IAAjB,EAAuBC,SAAvB,EAAkCN,aAAlC;AACD,GAZH;AAaA,SAAO;AACLoB,cAAUpB,cAAcqB,MAAd,IAAwB,CAD7B;AAELC,YAAQtB;AAFH,GAAP;AAID,CAnBD;;AAsBA,IAAMuB,yBAAyB,SAAzBA,sBAAyB,CAACR,GAAD,EAAMD,WAAN,EAAsB;AACnD,MAAMQ,SAASP,IAAIG,IAAJ,CAASM,GAAT,CAAa,UAACnB,IAAD,EAAOoB,SAAP,EAAqB;AAC/C,QAAMzB,gBAAgB,EAAtB;AACA,wBAAYc,WAAZ,EACGE,OADH,CACW,UAACC,KAAD,EAAW;AAClB,UAAMS,aAAaZ,YAAYG,KAAZ,CAAnB;AACA,UAAMX,YAAYD,KAAKqB,WAAWnB,IAAhB,CAAlB;AAFkB,UAGVY,QAHU,GAGGO,UAHH,CAGVP,QAHU;;AAIlB,UAAIA,QAAJ,EAAc;AACZ;AACD;AACD;AACAf,wBAAkBJ,aAAlB,EAAiC0B,UAAjC,EAA6CpB,SAA7C;AACA;AACAE,uBAAiBkB,UAAjB,EAA6BpB,SAA7B,EAAwCN,aAAxC;AACD,KAZH;AAaA,WAAO;AACLyB,0BADK;AAELE,kBAAY3B;AAFP,KAAP;AAID,GAnBc,CAAf;;AAqBA,SAAO;AACLoB,cAAUE,OAAOM,MAAP,CAAc;AAAA,aAAKC,EAAEF,UAAF,CAAaN,MAAb,GAAsB,CAA3B;AAAA,KAAd,EAA4CA,MAA5C,IAAsD,CAD3D;AAELC;AAFK,GAAP;AAID,CA1BD;;AA6BA;;;;;;;;;;;;;;;;;;;;;;AAsBA,IAAMQ,sBAAsB,SAAtBA,mBAAsB,CAACf,GAAD,EAAMD,WAAN,EAAsB;AAChD,MAAIjB,MAAMkB,IAAIG,IAAV,CAAJ,EAAqB;AACnB,WAAO;AACLE,gBAAU,KADL;AAELE,cAAQ,CAAC,6BAAD;AAFH,KAAP;AAID;AACD,MAAI,CAACxB,QAAQiB,IAAIG,IAAZ,CAAL,EAAwB;AACtB,WAAOL,0BAA0BC,WAA1B,EAAuCC,GAAvC,CAAP;AACD;AACD,SAAOQ,uBAAuBR,GAAvB,EAA4BD,WAA5B,CAAP;AACD,CAXD;;AAaAiB,OAAOC,OAAP,GAAiBF,mBAAjB","file":"validateRequestBody.js","sourcesContent":["const { isFunction, isNil, isArray } = require('lodash');\n\n/**\n * Add to errors list.\n * @param {any} reqBodyErrors\n * @param {any} prop\n * @param {any} message\n */\nconst addReqBodyError = (reqBodyErrors, prop, message) => {\n  reqBodyErrors.push({\n    prop,\n    message,\n  });\n};\n\n/**\n * Check if prop exists\n * @param {any} reqBodyErrors\n * @param {any} item\n */\nconst checkifPropExists = (reqBodyErrors, item, propValue) => {\n  if (item && isNil(propValue)) {\n    addReqBodyError(reqBodyErrors, item.name, `Property [${item.name}] is required.`);\n  }\n};\n\n/**\n * Invoke validators defined.\n * @param {any} item\n * @param {any} propValue\n * @param {any} reqBodyErrors\n */\nconst invokeValidators = (item, propValue, reqBodyErrors) => {\n  const validatorFunction = item.validator;\n  if (validatorFunction) {\n    if (isFunction(validatorFunction) && !isNil(propValue)) {\n      const validatorResult = validatorFunction.call(this, propValue);\n      // Validators function should always return boolean type\n      if (typeof (validatorResult) !== 'boolean') {\n        addReqBodyError(reqBodyErrors, item.name, `Property [${item.name}] validator [${validatorFunction.name}] not returning boolean.`);\n        // Validation failed\n      } else if (!validatorResult) {\n        addReqBodyError(reqBodyErrors, item.name, `Validation failed for Property [${item.name}] using validator [${validatorFunction.name}]`);\n      }\n    } else {\n      addReqBodyError(reqBodyErrors, item.name, `Property [${item.name}] validator property is not a function or there is no value to validate.`);\n    }\n  }\n};\n\nconst handleNonArrayRequestBody = (reqbodydefs, req) => {\n  const reqBodyErrors = [];\n  Object.keys(reqbodydefs)\n    .forEach((index) => {\n      const item = reqbodydefs[index];\n      const propValue = req.body[item.name];\n      const { nullable } = item;\n      if (nullable) {\n        return;\n      }\n      // Validate if prop has value\n      checkifPropExists(reqBodyErrors, item, propValue);\n      // Invoke validator function if there is one provided\n      invokeValidators(item, propValue, reqBodyErrors);\n    });\n  return {\n    allValid: reqBodyErrors.length <= 0,\n    errors: reqBodyErrors,\n  };\n};\n\n\nconst handleArrayRequestBody = (req, reqbodydefs) => {\n  const errors = req.body.map((item, itemIndex) => {\n    const reqBodyErrors = [];\n    Object.keys(reqbodydefs)\n      .forEach((index) => {\n        const definition = reqbodydefs[index];\n        const propValue = item[definition.name];\n        const { nullable } = definition;\n        if (nullable) {\n          return;\n        }\n        // Validate if prop has value\n        checkifPropExists(reqBodyErrors, definition, propValue);\n        // Invoke validator function if there is one provided\n        invokeValidators(definition, propValue, reqBodyErrors);\n      });\n    return {\n      itemIndex,\n      itemErrors: reqBodyErrors,\n    };\n  });\n\n  return {\n    allValid: errors.filter(x => x.itemErrors.length > 0).length <= 0,\n    errors,\n  };\n};\n\n\n/**\n * Validate request body based on the definition\n * @param {any} req\n * @param {any} reqbodydefs\n * [\n *  {\n *      \"name\": Property Name (Case-sensitive),\n *      \"validator\": function to validate should always return bool, otherwise it will fail\n *  }\n * ]\n * @returns\n * {\n *      \"allValid\": true / false,\n *      \"errors\" : [\n *                  {\n *                      \"prop\": Property Name,\n *                      \"message\": Error Message\n *                  },\n *                  ...\n *                 ]\n * }\n */\nconst validateRequestBody = (req, reqbodydefs) => {\n  if (isNil(req.body)) {\n    return {\n      allValid: false,\n      errors: ['Please pass a request body.'],\n    };\n  }\n  if (!isArray(req.body)) {\n    return handleNonArrayRequestBody(reqbodydefs, req);\n  }\n  return handleArrayRequestBody(req, reqbodydefs);\n};\n\nmodule.exports = validateRequestBody;\n"]}